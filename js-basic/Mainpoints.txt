ー非同期処理(fetch, async/await)についてー

基本的に関数を引数として渡すときは「.」の左側(レシーバorコンテキスト)は切り離される仕様
setTimeoutとかaddEventListenerとかでも同じ仕様。
レシーバは命令を受け取る側の意味でコンテキストはthisが誰かという状況の意味
jsのクラスはjavaとかCとかの全部の情報を渡しちゃうのと違ってプロトタイプだからデータだけおいて、リンクで親クラスを参照させる感じ。
だから親側を変えただけですべてのクラスに変更がされるってわけ。ちなみにこれは同期ではなく動的。
同期・非同期は時間軸で考えているのでそもそも動的・静的とは話が違う。

ー参照(Reference)についてー
数字・文字列・booleanはイミュータブル(不変)だから中身の値は変わらない。
反対にオブジェクト型は[]に参照がつくからミュータブル(可変)なので中身が変わってもok
中身がプリミティブ型の場合は中身に参照がつかない。
ネストの場合は話が変わって参照がついちゃうからややこしくなっちゃうから注意。
あとイミュータブルとミュータブルは静的と動的と同じなんだけどコード視点かメモリ視点かの違い

ーClosureについてー
constの変数はラベルの参照先を変更できないので常に同じ値がスコープされる
let、グローバル変数はラベルが変わったりするので同じ値ではない
ReactのuseState, useRefが必要な理由はここ。
useStateはconstの値を変更させるためのもの。set~で新たな値をとってそれをconstの初期値
とした新たな関数を作成する(前のものは消えないのでバグを起こす原因になり得る)
useRefはこの監視の穴を潜り抜けてるやつでオブジェクト型にすることでReactが中身をみない
ということを裏目にとって好き勝手に中身の数字を変えて常に最新の状態を記憶している